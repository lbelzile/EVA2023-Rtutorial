install.packages("rmarkdown")
install.packages("markdown")
install.packages("rmarkdown")
install.packages("knitr")
?revdbayes
#| eval: true
#| echo: false
library(ggplot2)
data("frwind", package = "mev")
lyon <- with(frwind,
xts::xts(x = S2, order.by = date))
ymax <- as.numeric(xts::apply.yearly(lyon, max))
#| eval: true
#| echo: true
library(revdbayes)
post <- revdbayes::rpost_rcpp(
n = 1e4L, # number of posterior samples
model = "gev", # extreme value distribution
data = ymax, # vector of yearly maximum
prior = set_prior(prior = "mdi", model = "gev"),
nrep = 100) # number of post. predictive samples
post_gev_ <- apply(post$sim_vals, 1, function(x){
revdbayes::qgev(p = 0.5, loc = x[1], scale = x[2],
shape = x[3], m = 50)
})
# Posterior mean and standard error
mean(post_gev_Nmed)
post_gev_Nmed <- apply(post$sim_vals, 1, function(x){
revdbayes::qgev(p = 0.5, loc = x[1], scale = x[2],
shape = x[3], m = 50)
})
# Posterior mean and standard error
mean(post_gev_Nmed)
sd(post_gev_Nmed)
# Posterior mean and standard error
mean(post_gev_Nmed); sd(post_gev_Nmed)/sqrt(nrow(post_gev_Nmed))
# Posterior mean and standard error
mean(post_gev_Nmed); sd(post_gev_Nmed)/sqrt(length(post_gev_Nmed))
# To get a 95% credible interval, simply compute quantiles
quantile(post_gev_mean, c(0.025, 0.975))
# To get a 95% credible interval, simply compute quantiles
quantile(post_gev_Nmed, c(0.025, 0.975))
sd(post_gev_Nmed)/sqrt(length(post_gev_Nmed))
?sd
# Posterior mean and standard error
mean(post_gev_Nmed)
# To get a 95% credible interval, simply compute quantiles
quantile(post_gev_Nmed, c(0.025, 0.975))
viridis::cividis(n=2)[1]
ymax
v
xts::apply.yearly(lyon, max)
library(texmex)
max_df <- data.frame(year = 1976:2023,
ymax = ymax)
texmex::evm(y = ymax ~ year,
data = max_df,
family = "gev")
ymax
max_df <- data.frame(year = 1976:2023,
ymax = ymax)
post_reg <- texmex::evm(y = ymax,
data = max_df,
family = "gev",
method = "simulate",
prior = "gaussian",
mu = ~ scale(year),
verbose = FALSE)
texmex::evm(y = ymax,
data = max_df,
family = "gev",
method = "simulate",
prior = "gaussian",
burn = 1000,
iter  = 4.1e4,
mu = ~ scale(year),
verbose = FALSE)
post_reg <- texmex::evm(y = ymax,
data = max_df,
family = "gev",
method = "simulate",
burn = 1000,
iter  = 4.1e4,
mu = ~ scale(year),
verbose = FALSE)
?evm
library(texmex)
post_reg <- texmex::evm(
y = ymax,
data = data.frame(
syear = scale(1976:2023),
ymax = ymax),
family = "gev",
method = "simulate",
burn = 1000L,
chain = 4L,
iter  = 1.1e4,
proposal.dist = "cauchy",
mu = ~ year,
verbose = FALSE)
library(texmex)
post_reg <- texmex::evm(
y = ymax,
data = data.frame(
syear = scale(1976:2023),
ymax = ymax),
family = "gev",
method = "simulate",
burn = 1000L,
chain = 4L,
iter  = 1.1e4,
proposal.dist = "cauchy",
mu = ~ syear,
verbose = FALSE)
texmex::evm(
y = ymax,
data = data.frame(
syear = scale(1976:2023),
ymax = ymax),
family = "gev",
method = "simulate",
burn = 1000L,
chain = 4L,
iter  = 1.1e4,
proposal.dist = "cauchy",
mu = ~ syear,
verbose = FALSE)
library(texmex)
post_reg <- texmex::evm(
y = ymax,
data = data.frame(
syear = scale(1976:2023),
ymax = ymax),
family = texmex::gev,
method = "simulate",
burn = 1000L,
chain = 4L,
iter  = 1.1e4,
proposal.dist = "cauchy",
mu = ~ syear,
verbose = FALSE)
post_reg
summary(post_reg)
methods(post_reg)
class(post_reg)
methods("evmSim")
coef(post_reg)
plot(post_reg)
library(texmex)
post_reg <- texmex::evm(
y = ymax,
data = data.frame(
syear = scale(1976:2023),
ymax = ymax),
family = texmex::gev,
method = "simulate",
burn = 1000L,
chain = 4L,
iter  = 1.1e4,
proposal.dist = "normal",
mu = ~ syear,
verbose = FALSE)
1.1e4
library(texmex)
post_reg <- texmex::evm(
y = ymax,
data = data.frame(
syear = scale(1976:2023),
ymax = ymax),
family = texmex::gev,
method = "simulate",
burn = 1000L,
chain = 4L,
iter  = 1.1e4,
proposal.dist = "gaussian",
mu = ~ syear,
verbose = FALSE)
summary(post_reg)
par(mfrow = c(3,4)); plot(post_reg)
plot(post_reg, which.plots = 2, chain = 1:4)
plot(post_reg, which.plots = 2, chain = 4)
plot(post_reg, which.plots = 2, chain = 3)
library(texmex)
post_reg <- texmex::evm(
y = ymax,
data = data.frame(
syear = scale(1976:2023),
ymax = ymax),
family = texmex::gev,
method = "simulate",
burn = 1000L,
chains = 4L,
iter  = 1.1e4,
proposal.dist = "gaussian",
mu = ~ syear,
verbose = FALSE)
summary(post_reg)
#| eval: false
# Density, Markov chains and correlograms
plot(post_reg, which.plots = 2, chains = 1:2)
#| eval: false
# Density, Markov chains and correlograms
plot(post_reg, which.plots = 2, chains = 1)
#| eval: false
# Density, Markov chains and correlograms
autoplot(post_reg, which.plots = 2, chains = 1)
library(texmex)
autoplot(post_reg, which.plots = 2, chains = 1)
rlang::last_trace()
library(ggplot2)
#| eval: false
# Density, Markov chains and correlograms
ggplot(post_reg, which.plots = 2, chains = 1)
?grid.arrange
#| eval: false
# Density, Markov chains and correlograms
library(gridExtra)
ggplot(post_reg, which.plots = 2, chains = 1)
post_reg$param
post_reg$chains]
post_reg$chains
test <- mcmc::as.mcmc(post_reg$chains)
install.packages("mcmc")
test <- mcmc::as.mcmc(post_reg$chains)
library(coda)
install.packages("coda")
library(coda)
test <- coda::as.mcmc(post_reg$chains)
test
coda(test)
test <- coda::as.mcmc.list(post_reg$chains)
test <- lapply(post_reg$chains, coda::as.mcmc)
test
plot(test)
coda::as.mcmc.list(test)
test <- coda::as.mcmc.list(test)
plot(test)
coda::traceplot(test)
coda::traceplot(test,smooth = TRUE)
chains <- coda::as.mcmc.list(lapply(post_reg$chains, coda::as.mcmc))
coda::plot.mcmc(chains, density = FALSE)
plot(chains, density = FALSE)
coda::effectiveSize(chains)
# we recommend running this is a fresh R session or restarting your current session
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
cmdstanr::install_cmdstan()
install.packages(c("loo","psis"))
?loo::
plot(chains, density = FALSE, auto.layout = FALSE)
ggplot(post_reg)
coda::batchSE(x = chains)
coda::acfplot(chains)
coda::gelman.diag(chains)
coda::geweke.diag(chains)
coda::codamenu(chains)
coda::codamenu
coda::codamenu()
mean(chains)
summary(chains)
install.packages("fda")
library(fda)
oldpar <- par(no.readonly=TRUE)
##
## 1.  b-spline
##
# set up the b-spline basis for the lip data, using 23 basis functions,
#   order 4 (cubic), and equally spaced knots.
#  There will be 23 - 4 = 19 interior knots at 0.05, ..., 0.95
lipbasis <- create.bspline.basis(c(0,1), 23)
# plot the basis functions
plot(lipbasis)
oldpar <- par(no.readonly=TRUE)
##
## 1.  b-spline
##
# set up the b-spline basis for the lip data, using 23 basis functions,
#   order 4 (cubic), and equally spaced knots.
#  There will be 23 - 4 = 19 interior knots at 0.05, ..., 0.95
lipbasis <- create.bspline.basis(c(0,1), 23)
# plot the basis functions
plot(lipbasis,axes = NULL)
oldpar <- par(no.readonly=TRUE)
##
## 1.  b-spline
##
# set up the b-spline basis for the lip data, using 23 basis functions,
#   order 4 (cubic), and equally spaced knots.
#  There will be 23 - 4 = 19 interior knots at 0.05, ..., 0.95
lipbasis <- create.bspline.basis(c(0,1), 23)
# plot the basis functions
plot(lipbasis,axes = NULL,knots = FALSE)
lipbasis$basisvalues
lipbasis$values
lipbasis$params
?lipbasis
?create.bspline.basis
install.packages("gratia")
load_mgcv()
library(gratia)
load_mgcv()
df <- data_sim("eg4", n = 400, seed = 42)
bf <- basis(s(x0), data = df)
draw(bf)
bf
bf <- basis(object = s(x0), bs = "tp")
bf <- basis(object = s(x0), bs = "cr")
bf <- basis(object = s(x0, bs = "cr"))
bf <- basis(object = s(x0, bs = "cr"), data = df)
plot(bf)
draw(bf)
draw(bf) + theme_classic()
draw(bf) + ggplot2::theme_classic()
bf <- basis(object = s(x0, bs = "tp"), data = df)
draw(bf) + ggplot2::theme_classic()
load_mgcv()
df <- data_sim("eg4", n = 400, seed = 42)
bf <- basis(s(x0), data = df)
draw(bf)
df
gam <- mgcv::gam(y ~ s(x0), data = df)
draw(gam)
gratia:::draw.basis(gam)
gratia:::draw_concurvity(gam)
install.packages("simstudy")

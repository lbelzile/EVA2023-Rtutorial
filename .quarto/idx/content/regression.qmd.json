{"title":"Regression models","markdown":{"yaml":{"title":"Regression models","page-layout":"full","title-block-banner":false,"cache":true},"headingText":"Generalized additive models for extremes","containsRefs":false,"markdown":"\n\n\nMost data encountered in applications display various forms of nonstationarity, including trends, time-varying variance, seasonality and covariate effects. In environmental applications, these may be partly attributed to the presence of different weather patterns or regimes, to climate change, etc. Extreme value distributions cannot capture these phenomena without modification. There is no general theory for nonstationary extremes, and therefore there are multiple strategies that one can consider for modelling. \n\nThe first consists in fitting a regression for the whole data and perform extreme value analysis with the residuals, as before assuming stationarity [@Eastoe.Tawn:2009]. The second, proposed by @Davison.Smith:1990, tries to incorporate covariates in the parameters $\\mu$, $\\sigma$, etc. --- fixing the shape parameters is often recommended as it is hard to estimate.\n\nGeneral linear modelling would consist in regression models, e.g.,\n\\begin{align*}\n\\mu(\\mathbf{X}) = \\beta_0 + \\beta_1 \\mathrm{X}_1 + \\cdots \\beta_p \\mathrm{X}_p,\n\\end{align*}\nand estimate as before parameters by maximum likelihood. The difficulty now is that there are more parameters to estimate and the support restriction translates into up to $n$ inequality constraints, as they must be supported for every combination of covariates found in the database. These two facts mean numerical optimization is more difficult.\n\nIn models with a relatively large number of parameters, it is useful to  include additive penalty terms to the log likelihood: for example, generalized additive models for the parameters include smooth functions, typically splines, with a penalty that controls the wiggliness of the estimated predictor functions. The latter is typically evaluated using the second-order derivative of the basis functions. \n\nFor example, consider a function of covariates $f(x_j) = \\sum_{k=1}^K \\beta_k b_k(x_j)$, where $b_k(\\cdot)$ is a basis function, possibly with compact support. We typically penalize the squared second derivative of the function $f(x)$ to control the wiggliness of the function. Since the regression coefficients $\\beta$'s are constants, the penalty can be expressed in terms of the second derivative of the basis functions concatenated in a smooth matrix $\\mathbf{S}$ with $(i,j)$th entry $S_{ij} = \\int b_i''(x) b_j''(x)\\mathrm{d} x$, so the penalty can be written $\\lambda \\boldsymbol{\\beta}^\\top \\mathbf{S}\\boldsymbol{\\beta}$ for some tuning parameter $\\lambda \\geq 0$ that controls the tuning. The penalty can be viewed in the Bayesian paradigm as an improper Gaussian prior. The optimal value of $\\lambda$ for smoothing is selected by maximizing the marginal likelihood: in high-dimensional settings, or when we include interactions through tensor products, etc., optimization of $\\boldsymbol{\\lambda}$ is far from trivial.\n\nThe `mgcv` package in **R** allows for estimation of generalized additive models using the methods described above. There are multiple choice of basis functions that can be used, including the default thin-plate spline `tp`, cubic splines `cs` and cubic cyclic splines `cc` for cyclic covariates such as period of year.\nWhile most software for generalized additive models will allow for The smooths consisting of linear combination of basis functions\n\nIn nonstationary models, risk measures of interest are defined conditionally on the value of covariates: for example, the $1-p$ conditional return level is [@Eastoe.Tawn:2009]\n\\begin{align*}\n\\Pr(Y_t  > y \\mid \\mathbf{X}_t =\\boldsymbol{x}_t) = p\n\\end{align*}\nand the corresponding unconditional return level,\n\\begin{align*}\n\\int_{\\mathcal{X}} \\Pr(Y_t  > y \\mid \\mathbf{X}_t =\\boldsymbol{x}_t) \\mathrm{d} P(\\boldsymbol{x}_t),\n\\end{align*}\n is obtained by averaging out over the distribution of covariates that are employed in the model. For future quantities, this may or not be a sensible risk summary to compute^[What does return levels mean in a nonstationary climate? See @Rootzen.Katz:2013 for an alternative.] and may prove tricky to obtain as it requires either knowledge about the future distribution of the covariates, or else a perhaps unrealistically strong stationary assumption.\n \nSome parametrizations are better suited than others for regression modelling: for the nonstationary case, the generalized Pareto model with varying scale and shape is not stationary unless, for any $v$ greater than the original threshold $u$, \n\\begin{align*}\n\\sigma_v(\\boldsymbol{x}_t) = \\sigma_u(\\boldsymbol{x}_t) + (v-u) \\xi(\\boldsymbol{x}_t)\n\\end{align*}\nwhich, even with constant shape $\\xi$ must imply a linear or constant functional form for $\\sigma_u$. Using the inhomogeneous Poisson point process representation avoids these problems.\n\n\nThe function `evgam` from the eponymous package allows one to specify smooth functional forms and objective estimation of the smoothing parameters using Laplace's methods [@Wood.Pya.Safken:2016], building on the `mgcv` package of Simon Wood [@Wood:2017:mgcv].\n\nThe setup is `evgam(formula, data, family, ...)`, where formula is a list of formula for parameters (in the order location, scale, shape) and `family` is the character string for the extreme value distribution. Choices include `gev`, `gpd`, `rlarg` and `ald` for asymmetric Laplace, used in quantile regression, among other.\n\n```{r}\n#| label: evgam-setup\nlibrary(evgam)\ndata(frwind, package = \"mev\")\nlyon <- with(frwind,\n             xts::xts(x = S2, order.by = date))\nymax <- xts::apply.yearly(lyon, max)\nyears <- unique(lubridate::year(lyon))\nopt_gev_spl <- evgam::evgam(\n  data = data.frame(\n    syear = scale(years),\n    ymax = ymax),\n  formula = list(ymax ~ s(syear, k = 5, bs = \"cr\"),\n                 ~ 1, \n                 ~ 1),\n  family = \"gev\")\n## Summary with coefficients\nsummary(opt_gev_spl)\n## Plot splines (if any)\nplot(opt_gev_spl)\n## Fitted value, depend on covariates\n# predict(opt_gev_spl)\n```\n\nInterpreting the penalty as an improper Gaussian prior, we can view this model under the Bayesian lens. The posterior distribution isn't available in closed-form, but we can do a Gaussian approximation at the mode on a suitable scale (e.g., log-scale), sample from this multivariate Gaussian approximation of $p(\\boldsymbol{\\theta}) \\stackrel{\\cdot}{\\sim}\\mathsf{No}_p$ and transform them back on the parameter scale. Given draws of $\\boldsymbol{\\theta}$, we can next simulate new realizations $p(Y \\mid \\boldsymbol{\\theta}, \\mathbf{X}_{\\text{new}})$ from the approximate posterior predictive  for new combinations of covariates, or even for the data matrix that was used as covariates for the fitted model (default).\n\n@fig-density-post-evgam shows the output density for the location parameter for each time period in the records, as this is the only parameter that varies as a function of time ($\\log(\\sigma)$ and $\\xi$ are drawn from the same marginal distribution, even if simulated sample values are different for each time period combination). If the model is severely overfitted, this will be visible because the posterior standard deviation will be tiny.\n\n```{r}\n#| eval: true\n#| echo: true\n#| label: fig-density-post-evgam\n#| fig-cap: \"Density plots of 1000 posterior samples based on a normal approximation to the posterior of the location parameter of the generalized extreme value distribution, colored by year.\"\n#| fig-align: 'center'\n#| out-width: '80%'\n## Simulate from the posterior of parameters\npost_sim <- simulate(opt_gev_spl, nsim = 1000L, seed = 2023)\nlibrary(ggplot2)\nggplot(\n  data = data.frame(\n    location = c(post_sim$location),\n    year = factor(rep(1:length(years), \n               length.out = prod(dim(post_sim$location))))),\n  mapping = aes(x = location,\n                color = year,\n                group = year)) +\n  geom_density() +\n  theme_minimal() +\n  viridis::scale_color_viridis(discrete = TRUE) +\n  theme(legend.position = \"none\")\n```\n\n","srcMarkdownNoYaml":"\n\n\nMost data encountered in applications display various forms of nonstationarity, including trends, time-varying variance, seasonality and covariate effects. In environmental applications, these may be partly attributed to the presence of different weather patterns or regimes, to climate change, etc. Extreme value distributions cannot capture these phenomena without modification. There is no general theory for nonstationary extremes, and therefore there are multiple strategies that one can consider for modelling. \n\nThe first consists in fitting a regression for the whole data and perform extreme value analysis with the residuals, as before assuming stationarity [@Eastoe.Tawn:2009]. The second, proposed by @Davison.Smith:1990, tries to incorporate covariates in the parameters $\\mu$, $\\sigma$, etc. --- fixing the shape parameters is often recommended as it is hard to estimate.\n\nGeneral linear modelling would consist in regression models, e.g.,\n\\begin{align*}\n\\mu(\\mathbf{X}) = \\beta_0 + \\beta_1 \\mathrm{X}_1 + \\cdots \\beta_p \\mathrm{X}_p,\n\\end{align*}\nand estimate as before parameters by maximum likelihood. The difficulty now is that there are more parameters to estimate and the support restriction translates into up to $n$ inequality constraints, as they must be supported for every combination of covariates found in the database. These two facts mean numerical optimization is more difficult.\n\nIn models with a relatively large number of parameters, it is useful to  include additive penalty terms to the log likelihood: for example, generalized additive models for the parameters include smooth functions, typically splines, with a penalty that controls the wiggliness of the estimated predictor functions. The latter is typically evaluated using the second-order derivative of the basis functions. \n\nFor example, consider a function of covariates $f(x_j) = \\sum_{k=1}^K \\beta_k b_k(x_j)$, where $b_k(\\cdot)$ is a basis function, possibly with compact support. We typically penalize the squared second derivative of the function $f(x)$ to control the wiggliness of the function. Since the regression coefficients $\\beta$'s are constants, the penalty can be expressed in terms of the second derivative of the basis functions concatenated in a smooth matrix $\\mathbf{S}$ with $(i,j)$th entry $S_{ij} = \\int b_i''(x) b_j''(x)\\mathrm{d} x$, so the penalty can be written $\\lambda \\boldsymbol{\\beta}^\\top \\mathbf{S}\\boldsymbol{\\beta}$ for some tuning parameter $\\lambda \\geq 0$ that controls the tuning. The penalty can be viewed in the Bayesian paradigm as an improper Gaussian prior. The optimal value of $\\lambda$ for smoothing is selected by maximizing the marginal likelihood: in high-dimensional settings, or when we include interactions through tensor products, etc., optimization of $\\boldsymbol{\\lambda}$ is far from trivial.\n\nThe `mgcv` package in **R** allows for estimation of generalized additive models using the methods described above. There are multiple choice of basis functions that can be used, including the default thin-plate spline `tp`, cubic splines `cs` and cubic cyclic splines `cc` for cyclic covariates such as period of year.\nWhile most software for generalized additive models will allow for The smooths consisting of linear combination of basis functions\n\nIn nonstationary models, risk measures of interest are defined conditionally on the value of covariates: for example, the $1-p$ conditional return level is [@Eastoe.Tawn:2009]\n\\begin{align*}\n\\Pr(Y_t  > y \\mid \\mathbf{X}_t =\\boldsymbol{x}_t) = p\n\\end{align*}\nand the corresponding unconditional return level,\n\\begin{align*}\n\\int_{\\mathcal{X}} \\Pr(Y_t  > y \\mid \\mathbf{X}_t =\\boldsymbol{x}_t) \\mathrm{d} P(\\boldsymbol{x}_t),\n\\end{align*}\n is obtained by averaging out over the distribution of covariates that are employed in the model. For future quantities, this may or not be a sensible risk summary to compute^[What does return levels mean in a nonstationary climate? See @Rootzen.Katz:2013 for an alternative.] and may prove tricky to obtain as it requires either knowledge about the future distribution of the covariates, or else a perhaps unrealistically strong stationary assumption.\n \nSome parametrizations are better suited than others for regression modelling: for the nonstationary case, the generalized Pareto model with varying scale and shape is not stationary unless, for any $v$ greater than the original threshold $u$, \n\\begin{align*}\n\\sigma_v(\\boldsymbol{x}_t) = \\sigma_u(\\boldsymbol{x}_t) + (v-u) \\xi(\\boldsymbol{x}_t)\n\\end{align*}\nwhich, even with constant shape $\\xi$ must imply a linear or constant functional form for $\\sigma_u$. Using the inhomogeneous Poisson point process representation avoids these problems.\n\n## Generalized additive models for extremes \n\nThe function `evgam` from the eponymous package allows one to specify smooth functional forms and objective estimation of the smoothing parameters using Laplace's methods [@Wood.Pya.Safken:2016], building on the `mgcv` package of Simon Wood [@Wood:2017:mgcv].\n\nThe setup is `evgam(formula, data, family, ...)`, where formula is a list of formula for parameters (in the order location, scale, shape) and `family` is the character string for the extreme value distribution. Choices include `gev`, `gpd`, `rlarg` and `ald` for asymmetric Laplace, used in quantile regression, among other.\n\n```{r}\n#| label: evgam-setup\nlibrary(evgam)\ndata(frwind, package = \"mev\")\nlyon <- with(frwind,\n             xts::xts(x = S2, order.by = date))\nymax <- xts::apply.yearly(lyon, max)\nyears <- unique(lubridate::year(lyon))\nopt_gev_spl <- evgam::evgam(\n  data = data.frame(\n    syear = scale(years),\n    ymax = ymax),\n  formula = list(ymax ~ s(syear, k = 5, bs = \"cr\"),\n                 ~ 1, \n                 ~ 1),\n  family = \"gev\")\n## Summary with coefficients\nsummary(opt_gev_spl)\n## Plot splines (if any)\nplot(opt_gev_spl)\n## Fitted value, depend on covariates\n# predict(opt_gev_spl)\n```\n\nInterpreting the penalty as an improper Gaussian prior, we can view this model under the Bayesian lens. The posterior distribution isn't available in closed-form, but we can do a Gaussian approximation at the mode on a suitable scale (e.g., log-scale), sample from this multivariate Gaussian approximation of $p(\\boldsymbol{\\theta}) \\stackrel{\\cdot}{\\sim}\\mathsf{No}_p$ and transform them back on the parameter scale. Given draws of $\\boldsymbol{\\theta}$, we can next simulate new realizations $p(Y \\mid \\boldsymbol{\\theta}, \\mathbf{X}_{\\text{new}})$ from the approximate posterior predictive  for new combinations of covariates, or even for the data matrix that was used as covariates for the fitted model (default).\n\n@fig-density-post-evgam shows the output density for the location parameter for each time period in the records, as this is the only parameter that varies as a function of time ($\\log(\\sigma)$ and $\\xi$ are drawn from the same marginal distribution, even if simulated sample values are different for each time period combination). If the model is severely overfitted, this will be visible because the posterior standard deviation will be tiny.\n\n```{r}\n#| eval: true\n#| echo: true\n#| label: fig-density-post-evgam\n#| fig-cap: \"Density plots of 1000 posterior samples based on a normal approximation to the posterior of the location parameter of the generalized extreme value distribution, colored by year.\"\n#| fig-align: 'center'\n#| out-width: '80%'\n## Simulate from the posterior of parameters\npost_sim <- simulate(opt_gev_spl, nsim = 1000L, seed = 2023)\nlibrary(ggplot2)\nggplot(\n  data = data.frame(\n    location = c(post_sim$location),\n    year = factor(rep(1:length(years), \n               length.out = prod(dim(post_sim$location))))),\n  mapping = aes(x = location,\n                color = year,\n                group = year)) +\n  geom_density() +\n  theme_minimal() +\n  viridis::scale_color_viridis(discrete = TRUE) +\n  theme(legend.position = \"none\")\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"regression.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","url":"https://lbelzile.github.io/EVA2023-tutorial","bibliography":["../files/bib/vignette.bib"],"csl":"../files/bib/apa.csl","theme":["litera","../html/custom.scss"],"title":"Regression models","page-layout":"full","title-block-banner":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}